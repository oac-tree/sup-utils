# CMake helper functions to write CMake package config files
#
# This module provides:
#
#   write_package_config_file(PACKAGE_NAME
#     VERSION package_version
#     TARGETS_FILE targets_file
#     VERSION_FILE version_file
#     OUTPUT output_file
#     INSTALL_DESTINATION install_destination
#     DEPENDENCIES dependency1 dependency2 ...
#     dependency1_FIND_OPTIONS option1 option2 ...
#   )
#
#   This function generates a package config file for the package with the given name.
#   The package config file will do the basic setup of a package, it will fetch
#   any required dependencies and then import the package targets and version config
#   file, checking that they exist first. It will also check that any required
#   components were found.
#   At the end a message will be printed to indicate that the package was found with
#   the location and version, this message will be printed only once per package,
#   respecting the QUIET option to find_package().
#
#   Arguments:
#     PACKAGE_NAME: The name of the package
#     VERSION: The version of the package, if not given PROJECT_VERSION will be used
#     TARGETS_FILE: The name of the package targets file, defaults to <PACKAGE_NAME>-targets.cmake
#     VERSION_FILE: The name of the package version file, defaults to <PACKAGE_NAME>-config-version.cmake
#     OUTPUT: The name of the package config file, defaults to <PACKAGE_NAME>-config.cmake
#     INSTALL_DESTINATION: The install destination for the package config file, defaults to
#       <CMAKE_INSTALL_LIBDIR>/cmake/<PACKAGE_NAME>
#     DEPENDENCIES: A list of dependencies to find, these will be found using find_dependency()
#     <dependency>_FIND_OPTIONS: A list of options to pass to find_dependency() for the given dependency
#
#   TARGETS_FILE and VERSION_FILE must be relative to the directory containing the package config file.
#
#   Example:
#     write_package_config_file(package DEPENDENCIES dep1 dep2)
#

include(CMakePackageConfigHelpers)

function(write_package_config_file PACKAGE_NAME)
  # Get any arguments that match the pattern <PACKAGE_NAME>_FIND_OPTIONS 
  # We need this because we don't know which dependencies to consider before parsing the arguments
  list(APPEND PACKAGE_FIND_OPTIONS_ARGS ${ARGN})
  list(FILTER PACKAGE_FIND_OPTIONS_ARGS INCLUDE REGEX "^[A-Za-z0-9_\\-]+_FIND_OPTIONS$")

  cmake_parse_arguments(
    PACKAGE
    "" "VERSION;OUTPUT;TARGETS_FILE;VERSION_FILE;INSTALL_DESTINATION" "DEPENDENCIES;${PACKAGE_FIND_OPTIONS_ARGS}"
    ${ARGN}
  )

  if(PACKAGE_UNPARSED_ARGUMENTS)
    message(FATAL_ERROR "write_package_config_file called with unknown arguments: ${PACKAGE_UNPARSED_ARGUMENTS}")
  endif()

  if(NOT PACKAGE_VERSION)
    set(PACKAGE_VERSION ${PROJECT_VERSION})
  endif()

  if(NOT PACKAGE_OUTPUT)
    set(PACKAGE_OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/${PACKAGE_NAME}-config.cmake)
  endif()

  set(PACKAGE_OUTPUT_TEMP ${PACKAGE_OUTPUT}.in)

  if(NOT PACKAGE_TARGETS_FILE)
    set(PACKAGE_TARGETS_FILE ${PACKAGE_NAME}-targets.cmake)
  endif()

  if(NOT PACKAGE_VERSION_FILE)
    set(PACKAGE_VERSION_FILE ${PACKAGE_NAME}-config-version.cmake)
  endif()

  if(NOT PACKAGE_INSTALL_DESTINATION)
    set(PACKAGE_INSTALL_DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PACKAGE_NAME})
  endif()

  # Create the package config file template, this will be configured later
  # set minimum required version to 3.5 and check that the package name matches
  # PACKAGE_INIT will be replaced with the CMake package init containing utility functions
  set(PACKAGE_CONFIG_CONTENT
    "# Generated by CMake with write_package_config_file()
# Do not edit this file manually

cmake_minimum_required(VERSION 3.5)

if(DEFINED CMAKE_FIND_PACKAGE_NAME AND NOT \"${PACKAGE_NAME}\" STREQUAL CMAKE_FIND_PACKAGE_NAME)
  message(AUTHOR_WARNING
    \"The name passed to `find_package()` (\$\{CMAKE_FIND_PACKAGE_NAME\})\"
    \" does not match the package name (\\\"${PACKAGE_NAME}\\\").\"
    \" This can lead to problems in calling code that expects `find_package`\"
    \" result variables (e.g., `_FOUND`) or target names to follow a certain pattern.\"
  )
endif()
@PACKAGE_INIT@
"
  )

  # Add required dependencies if any
  if(PACKAGE_DEPENDENCIES)
    string(APPEND PACKAGE_CONFIG_CONTENT
      "
# Package dependencies
include(CMakeFindDependencyMacro)
"
    )

    foreach(DEPENDENCY ${PACKAGE_DEPENDENCIES})
      # Append any specified find options to the dependency
      list(JOIN PACKAGE_${DEPENDENCY}_FIND_OPTIONS " " DEPENDENCY_FIND_OPTIONS)
      string(JOIN " " DEPENDENCY ${DEPENDENCY} ${DEPENDENCY_FIND_OPTIONS})
      # Add the find_dependency() call to the package config file
      string(APPEND PACKAGE_CONFIG_CONTENT "find_dependency(${DEPENDENCY})\n")
    endforeach()
  endif()

  # Add the main body of the package config file, importing the targets and version files
  string(APPEND PACKAGE_CONFIG_CONTENT
    "
# Import package targets
set_and_check(${PACKAGE_NAME}_TARGETS_FILE \$\{CMAKE_CURRENT_LIST_DIR\}/${PACKAGE_TARGETS_FILE})
include(\$\{${PACKAGE_NAME}_TARGETS_FILE\})

# Import package version file
set_and_check(${PACKAGE_NAME}_VERSION_FILE \$\{CMAKE_CURRENT_LIST_DIR\}/${PACKAGE_VERSION_FILE})
include(\$\{${PACKAGE_NAME}_VERSION_FILE\})

# Check required components were found
check_required_components(${PACKAGE_NAME})

# Print find_package result
include(FindPackageMessage)
find_package_message(
  ${PACKAGE_NAME}
  \"Found ${PACKAGE_NAME}: \$\{CMAKE_CURRENT_LIST_DIR\} (found version \\\"\$\{PACKAGE_VERSION\}\\\")\"
  \"[\$\{CMAKE_CURRENT_LIST_DIR\}][v\$\{PACKAGE_VERSION\}]\"
)
"
  )

  # Write the package config file template to a temporary file and then configure it
  file(WRITE ${PACKAGE_OUTPUT_TEMP} ${PACKAGE_CONFIG_CONTENT})
  configure_package_config_file(
    ${PACKAGE_OUTPUT_TEMP} ${PACKAGE_OUTPUT}
    INSTALL_DESTINATION ${PACKAGE_INSTALL_DESTINATION}
  )

  # Remove the temporary file
  file(REMOVE ${PACKAGE_OUTPUT_TEMP})
endfunction()
